= plugin management =

Traditionally plugins were mantained manually by extracting files into
$HOME/.vim. Wrong about this approach is that its hard to maintain because its
you having to keep track about which files belong to each plugin.
:h plugin  tells you about this traditional way.

The next advanced way is create a directory for each plugin like this:

  ~/.vim/plugin-A/plugin/a.vim
  ~/.vim/plugin-A/filetype/a.vim
  ~/.vim/plugin-B/plugin/a.vim
  ~/.vim/plugin-B/filetype/a.vim

and add to your .vimrc:

  set runtimepath+=~/.vim/plugin-A
  set runtimepath+=~/.vim/plugin-B

This tells Vim that it should look for plugin files to source at startup in
additional directories. What's wrong about this?
Nothing except for example vim does not source plugin-A/plugin/after/*.vim
files.

Pathogen does exactly this by its pathogen#infect (and provides some more
helper functions to run helptags etc)

Vundle was also written to checkout plugin from git repositories

Feature matrix:

manipulate runtimepath: VAM, Pathogen, Vundle
install from git repositories: VAM, Vundle
install other sources: VAM
activate plugins at runtime: VAM
supports dependencies: VAM
plugin name completion and info: VAM
bootstrap from .vimrc: VAM (you can write this code for the other managers easily)
updating plugins: VAM (what about the others?)

Now it might look that being able to install from git repositories only is a major disadvantage.
Its not because there is vim-scripts.org mirroring www.vim.org plugins in git repositories.

What about git submodules? They are used to embed git repositories into
existing git repositories. Thus style is used to reproduce the exact behaviour on
a new machine. It can be used with any plugin manager - as long as plugins are
checked out by git.
